# 4 주차 대표 문제
<details>
<summary>copy on write에 대해 설명하세요.</summary>
<div markdown="1">
    copy on write 는 값 타입을 복사할 때 값을 수정하기 전까지는 실제로 복사하지 않아 메모리 사용을 최적화하는 방법입니다. 값 타입인 배열을 다른 변수에 할당하면 주소 값만 공유하고 있다가 변경이 생겼을 때 실제로 값을 복사합니다.
</div>
</details>

<details>
<summary>클래스가 구조체보다 느린 이유를 설명하시오.</summary>
<div markdown="1">
    힙 영역에 데이터를 할당하면서 생기는 locking이나 동기화 메커니즘에서 생긴다 생각합니다. 예를 들어, 여러 쓰레드에서 어떠한 클래스 객체를 동시에 힙 메모리에 할당할 때 이 locking을 통해 스레드 세이프한 무결성을 보호해야 하기 때문에 lock이 발생하게 됩니다. 그리고 사용되지 않은 적당한 공간을 찾아 일단 할당한 후, 사용이 끝나면 다시 힙을 lock한 후에 메모리를 해제하고 다시 적절한 위치로 재삽입을 실행합니다. 이러한 과정은 stack에 할당되는 구조체보다 훨씬 더 다이나믹한 방법으로 할당이 진행되는 것이고, 이는 성능 저하가 일어나는 요인이 됩니다.
    또한, 참조 카운팅에서 속도가 느려질 수 있는데, 마찬가지로 여러 쓰레드에서 동일한 인스턴스에 접근할 때도 이 카운팅은 atomic하게 진행되어야 하기 때문에 마찬가지로 lock이 일어나고, 이러한 카운팅이 자주 일어난다면, 이에대한 비용이 증가할 수 있습니다.
    다이나믹 디스패치를 활용하기 때문입니다. 클래스는 다형성을 만족하기 위해 메서드 호출 시 어떤 메서드를 호출할 것인지를 런타임 시에 결정합니다. 따라서,  알맞는 메서드를 찾아 테이블에서 검색을 진행하고, 그 메서드의 위치로 이동하는 과정이 동반되기 때문에 컴파일러의 인라이닝 기법과 같은 최적화가 불가능해지고, 그에따라 미미하지만 약간의 성능 저하가 일어날 수 있게 됩니다.
</div>
</details>

<details>
<summary>구조체의 mutating func에 대해서 설명해주세요</summary>
<div markdown="1">
    구조체는 값타입이기 때문에 기본적으로 프로퍼티는 인스턴스 메서드 내에서 수정될 수 없습니다. 따라서 수정이 필요하다면 func 키워드 전에 mutating을 위치시켜 변경하도록 할 수 있습니다. mutating 메서드는 암시적으로 self 프로퍼티에 새로운 인스턴스를 할당하고 새로운 인스턴스는 메서드가 종료되면 기존에 존재하던 인스턴스를 대체하게 됩니다.
</div>
</details>

<details>
<summary>동적 디스패치와 정적 디스패치에 대해서 설명해주세요</summary>
<div markdown="1">
    정적 디스패치는 컴파일 타입에 실행할 구현을 결정할 수 있는 경우를 뜻합니다. 동적 디스패치는 어떤 구현으로 이동할지 컴파일 타입에 결정할 수 없고 런타임에 실제로 구현을 조회한 다음 해당 구현으로 건너 뜁니다.
</div>
</details>

<details>
<summary>싱글턴 패턴의 장점과 단점을 말해주세요.</summary>
<div markdown="1">
    장점은 인스턴스 비용감소와 Thread Safe하다는 점입니다. 
    하나의 인스턴스를 만들고 그 인스턴스를 공유하기 때문에 인스턴스 생성 비용이 감소하며, static let으로 생성하기 때문에 여러개의 스레드에서 동시접근을 해도 한번만 초기화가 됩니다.
    단점은 의존성문제가 발생한다는 점입니다. 테스트를 진행시 테스트가 서로 독립적이어야 하지만 하나의 인스턴스를 기반으로 구현되는 패턴이므로 각 테스트 마다 독립적인 인스턴스를 만들기가 어렵습니다.
    중요 정보가 shared라는 하나의 객체에 담겨있기때문에 보안에 취약하다는 점입니다.
</div>
</details>

# 4 주차 문제
## Wonbi
1. **싱글턴 패턴이 무엇인지 설명하시오.**
    a. 싱글턴 패턴은 공통된 정보를 가진 하나의 객체만 전역에 존재하도록 하여 공용으로 사용하기 위한 디자인 패턴입니다.
2. **싱글턴 패턴을 class로 사용하는 이유에 대해 설명하시오.**
    a. 싱글턴 패턴은 하나의 인스턴스만 존재해야 하기 때문에, 새로운 값에 할당하더라도 하나의 객체만 참조해야 합니다. 하지만, 값타입으로 싱글턴 객체를 만들면, 새로운 값에 할당할 때마다 객체를 복사해서 새로운 객체를 만들어버리기 때문에 공통된 정보를 공용으로 사용하는 싱글턴 패턴의 취지와 맞지 않는 구조가 되버리기 때문에 참조타입인 class를 사용해야 합니다.
3. **구조체와 클래스의 차이점을 설명하시오.**
    a. 가장 큰 차이점은 값 타입과 참조 타입이라는 차이점이라고 생각합니다. 구조체는 값타입이기 때문에 메모리 Stack영역에만 존재하고, 클래스는 참조 타입이기 때문에 메모리 Heap영역에 객체가 존재하고 그 객체를 참조하는 포인터개념의 값이 Stack영역에 존재하여 그 객체를 참조하고 있습니다.
4. **Copy On Write는 어떤 방식으로 동작하는지 설명하시오.**
    a. CoW는 값 타입에서 일어나는 방식으로, 값을 복사할 때 실제 원본이나 복사본이 수정되기 전까지 값을 복사하지 않고 참조만 하고 있다가 실제 수정이 일어났을 때 복사가 일어납니다.
5. **클래스가 구조체보다 느린 이유를 설명하시오.**
    a.힙 영역에 데이터를 할당하면서 생기는 locking이나 동기화 메커니즘에서 생긴다 생각합니다. 예를 들어, 여러 쓰레드에서 어떠한 클래스 객체를 동시에 힙 메모리에 할당할 때 이 locking을 통해 스레드 세이프한 무결성을 보호해야 하기 때문에 lock이 발생하게 됩니다. 그리고 사용되지 않은 적당한 공간을 찾아 일단 할당한 후, 사용이 끝나면 다시 힙을 lock한 후에 메모리를 해제하고 다시 적절한 위치로 재삽입을 실행합니다. 이러한 과정은 stack에 할당되는 구조체보다 훨씬 더 다이나믹한 방법으로 할당이 진행되는 것이고, 이는 성능 저하가 일어나는 요인이 됩니다.
    a. 또한, 참조 카운팅에서 속도가 느려질 수 있는데, 마찬가지로 여러 쓰레드에서 동일한 인스턴스에 접근할 때도 이 카운팅은 atomic하게 진행되어야 하기 때문에 마찬가지로 lock이 일어나고, 이러한 카운팅이 자주 일어난다면, 이에대한 비용이 증가할 수 있습니다.
    a. 다이나믹 디스패치를 활용하기 때문입니다. 클래스는 다형성을 만족하기 위해 메서드 호출 시 어떤 메서드를 호출할 것인지를 런타임 시에 결정합니다. 따라서,  알맞는 메서드를 찾아 테이블에서 검색을 진행하고, 그 메서드의 위치로 이동하는 과정이 동반되기 때문에 컴파일러의 인라이닝 기법과 같은 최적화가 불가능해지고, 그에따라 미미하지만 약간의 성능 저하가 일어날 수 있게 됩니다.

## 준호
1. **언제 구조체 대신 클래스를 사용하는 게 좋은가요?**
   a. Objective-C API를 사용하거나 Objective-C 프레임워크에 정의된 기존 클래스를 사용할 때는 클래스를 사용해야 합니다. 데이터의 고유값을 관리해야하는 경우에도 클래스를 사용합니다.
2. **언제 클래스 대신 구조체를 사용하는 게 좋은가요?**
   a. 간단한 값을 캡슐화하는 것이 목적일 때, 인스턴스가 참조되기 보다는 복사되는 것이 적절한 경우에 사용합니다. 저장 프로퍼티가 값 타입이며 참조하는 것보다 복사하는 것이 합당할 때 사용합니다. 프로퍼티나 메서드를 상속할 필요가 없는 경우에 사용합니다.
3. **값 타입과 참조 타입의 차이점을 설명하세요.**
   a. 다른 변수에 할당하거나 어떤 함수의 전달인자로 전달할 때 값 타입은 값을 복사하지만 참조 타입 값을 복사하지 않고 참조를 전달합니다. 값 타입을 변수에 할당하면 스택 영역에 값이 저장되지만 참조 타입을 변수에 할당하면 스택 영역에는 주소만 할당되고 실제 데이터는 힙 영역에 할당됩니다.
4. **copy on write에 대해 설명하세요.**
   a. copy on write 는 값 타입을 복사할 때 값을 수정하기 전까지는 실제로 복사하지 않아 메모리 사용을 최적화하는 방법입니다. 값 타입인 배열을 다른 변수에 할당하면 주소 값만 공유하고 있다가 변경이 생겼을 때 실제로 값을 복사합니다.
5. **싱글턴 패턴을 클래스로 구현하는 이유는 무엇인가요?**
   a. 싱글턴 패턴의 목적인 유일한 객체를 사용하기 위해서 클래스를 사용해서 구현합니다. 구조체는 값 타입이기 때문에 구조체로 싱글턴을 구현하면 싱글턴 객체를 인스턴스화할 때 유일하지 못한 객체가 됩니다.

## 미니
1. **struct와 class의 차이점을 설명해주세요.**
    a. struct와 class의 가장 큰 차이점은 값타입과 참조 타입이라는 것입니다. 클래스는 참조 타입이기 때문에 ARC를 통해서 메모리 관리를 하게 됩니다. 또한, 인스턴스를 여러개의 변수에 할당한 뒤 값을 변경시키면 모든 변수에 영향을 줍니다. 또한, 클래스는 상속이 가능합니다. 하지만, 구조체는 값타입이기 때문에 새로운 변수에 구조체를 할당 할 때 마다 새로운 구조체가 할당되게 됩니다.
2. **클래스 대신 구조체를 사용하면 어떤 점이 좋을 까요?**
    a. 구조체는 불변성을 유지하기 때문에 여러개의 쓰레드들이 한 인스턴스를 활용하는 다중 스레드 환경에서도 안전하게 활용할 수 있습니다. 또한, 할당 영역이 Stack이기 때문에 힙에 저장되는 class보다 더욱 빠릅니다.
3. **언제 클래스를 사용해야 할까요?**
    a. 어떤 인스턴스의 참조값의 고유성을 유지하고 싶다면, Class를 활용할 수 있습니다. 또한, Object-c API를 활용할 때 클래스가 반드시 필요하기도 합니다.
4. **싱글턴 패턴을 활용하면 어떤 장점이 있을까요?**
    a. 한개의 Instance만 생성되므로 메모리 낭비를 방지 할 수 있습니다. 또한, 전역적으로 다른 클래스들과 자원 공유가 쉬워집니다.
5. **Swift에서 thread-safety한 싱글톤을 생성하는 방법에 대해서 이야기 해주세요.**
    a. 일반적으로 구성하는 방법과 동일합니다. 그 이유는 전역변수를 활용하여서 인스턴스를 생성하게 되면, 사용 시점에 초기화가 되고, GCD의 Dispatch_Once도 자동적용되어 인스턴스가 생성됩니다. 그렇기 때문에 Swift는 일반적인 방법으로 Thread-Safe하게 구성할 수 있습니다.

## 하모
1. **구조체와 클래스의 공통점에 대해서 설명해주세요**
    a. 프로퍼티, 메서드, 서브스크립트, 이니셜라이저를 정의할 수 있고 확장을 할 수 있고 프로토콜을 준수할 수 있습니다.
2. **구조체의 mutating func에 대해서 설명해주세요**
    a. 구조체는 값타입이기 때문에 기본적으로 프로퍼티는 인스턴스 메서드 내에서 수정될 수 없습니다. 따라서 수정이 필요하다면 func 키워드 전에 mutating을 위치시켜 변경하도록 할 수 있습니다. mutating 메서드는 암시적으로 self 프로퍼티에 새로운 인스턴스를 할당하고 새로운 인스턴스는 메서드가 종료되면 기존에 존재하던 인스턴스를 대체하게 됩니다.
3. **구조체가 클래스보다 성능적으로 뛰어난 이유에 대해서 설명하고, 예외는 어떤 상황인지 설명해주세요.**
    a. 구조체는 값타입이기 때문에 기본적으로 stack에 할당되고 클래스는 참조타입이기 때문에 기본적으로 heap에 할당되는데 stack의 경우 메모리 공간을 할당할 떄 스택포인터를 이동시켜 메모리 공간을 할당하고 heap의 경우 동적으로 메모리를 할당하기 때문에 그 만큼의 오버헤드가 발생합니다. 그리고 참조 타입은 할당해제를 위해서 ARC를 사용하기 때문에 reference count를 조작해야하는 오버헤드가 발생하게됩니다. 이에반해 stack은 스택포인터를 내리기만 하면 할당해제 되기 때문에 성능적으로 더 뛰어납니다. 하지만 구조체 내부에 2개이상의 참조타입을 소유하게 되면 reference count에서 발생하는 오버헤드가 클래스에 비해 배로 증가하기 때문에 이런 상황에서는 클래스가 더 성능면에서 더 효율적입니다.
4. **동적 디스패치와 정적 디스패치에 대해서 설명해주세요**
    a. 정적 디스패치는 컴파일 타입에 실행할 구현을 결정할 수 있는 경우를 뜻합니다. 동적 디스패치는 어떤 구현으로 이동할지 컴파일 타입에 결정할 수 없고 런타임에 실제로 구현을 조회한 다음 해당 구현으로 건너 뜁니다.
    - **동적 디스패치와 정적 디스패치의 성능 차이에 대해서 설명해주세요**
        a. 동적 디스패치는 그 자체로는 정적 디스패치보다 비용이 많이 들지는 않으나, 동적 디스패치는 컴파일러의 가시성을 차단하므로 컴파일러의 최적화를 막습니다.
    - **동적 디스패치는 왜 사용하는가요??**
        a. 동적 디스패치는 다형성을 가능하게 하기 때문입니다. 다형성이란 한 타입의 참조 변수가 여러 타입의 객체를 참조할 수 있는 것입니다. 다형성을 이용해서 유연하고 변경에 용이한 프로그램을 만들 수 있기 때문에 중요하다고 생각합니다.
    - **그럼 모든 class 동적 디스패치로 동작하나요??**
        a. class에 final 키워드를 명시하게되면 해당 클래스는 상속되지 않기 때문에 컴파일러는 정적 디스패치를 수행하게 됩니다.
    
## 쿄
1. **싱글턴 패턴의 장점과 단점을 말해주세요.**
    a. 장점은 인스턴스 비용감소와 Thread Safe하다는 점입니다. 
    하나의 인스턴스를 만들고 그 인스턴스를 공유하기 때문에 인스턴스 생성 비용이 감소하며, static let으로 생성하기 때문에 여러개의 스레드에서 동시접근을 해도 한번만 초기화가 됩니다.
    단점은 의존성문제가 발생한다는 점입니다. 테스트를 진행시 테스트가 서로 독립적이어야 하지만 하나의 인스턴스를 기반으로 구현되는 패턴이므로 각 테스트 마다 독립적인 인스턴스를 만들기가 어렵습니다.
    중요 정보가 shared라는 하나의 객체에 담겨있기때문에 보안에 취약하다는 점입니다.
2. **구조체와 클래스의 메모리 관점에서의 차이점은 무엇인가요?**
    a. 구조체의 경우 인스턴스를 생성할 경우, Stack 영역에 할당이 됩니다. 하지만 클래스의 경우 객체는 Heap 영역에 저장되고, Heap영역의 객체를 가리키는 주소값이 Stack영역에 저장됩니다.
3. **그럼 어떤 경우에 클래스를 사용하나요?**
    a. 클래스는 상속이 필요한 경우, Objective-C와 상호운용성을 원할 경우, ARC로 메모리관리가 필요한 경우 사용합니다.
4. **그러면 구조체는 어떤 장점이 있나요?**
    a. 구조체는 클래스와 달리 Static Dispatch로 동작합니다. 때문에 컴파일을 할 경우, 메서드 인라이닝으로 인해서 클래스보다 동작속도가 빠르다는 장점이 있습니다. 또한 구조체는 Stack에만 할당이 되기때문에 RC가 발생하지 않으며, 메모리 할당해제가 필요없다는 점이 있습    니다.
5. **그러면 항상 클래스는 구조체보다 느리고 성능이 안좋나요? 이유도 같이 설명해주세요.**
   a. 아닙니다. 구조체 내부에 클래스 타입의 프로퍼티가 2개 이상 일 경우에는 클래스 내부에 클래스 프로퍼티가 있는 경우보다 RC 비용이 훨씬 많이 발생하게 됩니다. 때문에 상황에 맞는 사용을 해야합니다.
